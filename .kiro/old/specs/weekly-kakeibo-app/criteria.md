# 観点：基本設計書と詳細設計書の品質・役割チェックリスト

## 1. 役割と対象者に関する観点

| 比較項目 | 基本設計書 (外部設計 / HLD) | 詳細設計書 (内部設計 / LLD) | チェック項目 |
| :--- | :--- | :--- | :--- |
| **主な役割** | **WHAT** (何を作るか) と **HOW** (どう動くか) の概要を定義 | **HOW** (どうやって作るか) の具体的な実装方法を定義 | 役割分担が明確か？ |
| **目的** | 顧客との**認識の合意**、プロジェクトの**方向性**を示す。 | プログラマーへの**具体的な実装指針**を提供する。 | 目的が適切に達成されているか？ |
| **主な対象者** | **顧客**、プロジェクト管理者、SE | **プログラマー**、SE、開発チーム内部 | 対象者に合わせた表現か？ |
| **視点** | **利用者**の視点 (外部仕様) | **開発者**の視点 (内部構造) | 視点がブレていないか？ |

---

## 2. プロセスと成果物の粒度に関する観点

### 2-1. プロセスチェック

| フェーズ | 目的 | 成果物 | チェック項目 |
| :--- | :--- | :--- | :--- |
| **基本設計** | 要件定義を基に、システム全体の概要と外部仕様を確定する。 | **基本設計書** | **要件**を過不足なく反映しているか？次の詳細設計に進める状態か？ |
| **詳細設計** | 基本設計を基に、内部構造と実装手順を確定する。 | **詳細設計書** | **基本設計**の全ての機能に対する実装方法が記述されているか？ |

### 2-2. 記述の粒度チェック

| 設計書 | 記述の粒度 | 記述範囲 (焦点) |
| :--- | :--- | :--- |
| **基本設計書** | 大まか、抽象的、**マクロな視点** | システム構成図、画面・帳票レイアウト、主要なデータフロー |
| **詳細設計書** | 詳細、具体的、**ミクロな視点** | プログラムロジック、クラス/メソッド仕様、DBアクセス手順、エラー処理 |

---

## 3. 成果物の品質と可読性に関する観点

### 3-1. 基本設計書の品質チェック

| 観点 | あるべき姿 (ゴール) | 詳細なチェック項目 |
| :--- | :--- | :--- |
| **可読性** | **顧客**が内容をチェックしやすいこと。専門用語の定義があること。 | 専門用語が乱用されていないか？図やモックアップが**直感的**か？ |
| **網羅性** | 利用者の視点でシステムの操作方法や動作が完全に理解できること。 | 画面/帳票の一覧と、それらの**操作手順（ユースケース）**が明確か？ |
| **一貫性** | あいまいさがなく、機能とビジネス要件の紐付けが明確であること。 | 動作のあいまいな表現 (例: 「〜など」「適宜」) が残っていないか？ |

### 3-2. 詳細設計書の品質チェック

| 観点 | あるべき姿 (ゴール) | 詳細なチェック項目 |
| :--- | :--- | :--- |
| **実装可能性** | **プログラマー**が迷わず、**そのままコーディング**できるレベルであること。 | **入出力、処理ロジック**が不足なく記述されているか？ |
| **統一性** | 記述ルールが統一され、理解しやすい構成であること。 | **記述ルール**（命名規則、エラーコードなど）が守られているか？UML図などで**構造**が可視化されているか？ |
| **トレース** | 基本設計書のどの機能に対応するかをすぐに追跡できること。 | 基本設計書の機能IDとの**対応付け**がされているか？ |
| **堅牢性** | 例外的な状況への対応が考慮されていること。 | **エラー処理**（入力チェック、例外処理）の具体的な実装が記述されているか？ |

---


## 4. 詳細設計書の記述スタイルに関する観点

### 4-1. コードの記述に関するルール

| 観点 | ルール | 理由 |
| :--- | :--- | :--- |
| **コードの記載** | 詳細設計書には**実装コードを記載しない**こと。 | 設計書はコードではなく、**設計の意図と方針**を伝えるもの。コードは実装フェーズで書くべき。 |
| **記述方法** | 処理の流れ、ロジック、データ構造を**言葉で説明**すること。 | プログラマーが理解しやすく、実装の自由度を保つため。 |
| **図の活用** | 複雑なロジックは**フローチャート**や**シーケンス図**で表現すること。 | 視覚的に理解しやすく、実装の指針となる。 |

### 4-2. 詳細設計書に記載すべき内容

| 項目 | 記載内容 | 記載例 |
| :--- | :--- | :--- |
| **処理フロー** | 関数やメソッドの処理手順を順序立てて説明 | 「1. 認証チェックを実行、2. バリデーションを実行、3. データベースに保存」 |
| **入出力** | 関数の入力パラメータと出力の型・形式 | 「入力: TransactionInput型、出力: Promise<Transaction>」 |
| **エラーハンドリング** | エラーの種類と処理方法 | 「ZodErrorの場合、バリデーションエラーメッセージを返す」 |
| **依存関係** | 使用するモジュールやライブラリ | 「Clerkの認証機能、Prismaのデータベースアクセス」 |
| **設計判断** | なぜその設計にしたのかの理由 | 「シングルトンパターンを採用し、接続プールを効率的に管理」 |

### 4-3. 避けるべき記述

| 避けるべき記述 | 理由 | 代替案 |
| :--- | :--- | :--- |
| **具体的なコード** | 設計書がコードになってしまう | 処理の流れを言葉で説明 |
| **実装の詳細** | 実装者の自由度を奪う | 設計の方針と制約を示す |
| **コピー&ペースト可能な内容** | 設計書ではなく実装になる | 設計の意図を伝える |

### 4-4. 良い詳細設計書の例

**悪い例（コードを記載）**:
```typescript
export function mapTransactionsToDomain(transactions: unknown[]): Transaction[] {
  return transactions.map(transaction => TransactionSchema.parse(transaction));
}
```

**良い例（言葉で説明）**:
- 関数名: `mapTransactionsToDomain`
- 処理内容: 配列の各要素に対してループ処理を実行し、TransactionSchemaでパース（バリデーション + 型変換）を行う
- パース成功時: 型安全なTransactionオブジェクトを配列に追加
- パース失敗時: ZodErrorをスロー（処理を中断）
- 設計判断: Zodスキーマを活用し、バリデーションとマッピングを一度に実行することで、コードの簡潔性を保つ
